import os
from config import Config

class AdvancedSRTtoASSConverter:
    def __init__(self, config: Config):
        """Initialize with video frame dimensions for adaptive subtitles."""
        self.config = config
        self.word_threshold = 0.1  # Time (s) below which words will merge

    def _generate_ass_header(self):
        """Generates ASS header with video resolution for proper scaling."""
        return f"""[Script Info]
    ; Script generated by Advanced SRT to ASS Converter
    Title: Word-Level Animated Subtitles
    ScriptType: v4.00+
    Collisions: Normal
    PlayResX: {self.config.video_resolution[0]}  ; **Sets correct width**
    PlayResY: {self.config.video_resolution[1]} ; **Sets correct height**
    PlayDepth: 0

    [V4+ Styles]
    Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
    Style: Default,Z003,{self._calculate_font_size()},&H00FFFFFF,&H0000FFFF,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,4,1,5,20,20,40,1

    [Events]
    Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
    """


    def convert(self, subs, ass_file_name):
        """Converts an SRT file with word-level timestamps to an animated ASS subtitle file."""
        frame_width, frame_height = self.config.video_resolution
        
        
        with open(ass_file_name, 'w', encoding='utf-8') as file:
            file.write(self._generate_ass_header())

            for sub in subs:
                time_start = sub['start']
                time_end = sub['end']
                text = sub['word']
                words = text.split()
                word_durations = self._split_word_durations(time_start, time_end, len(words))

                grouped_words, grouped_times = self._group_fast_words(words, word_durations)

                for i, (word_group, (start_offset, end_offset)) in enumerate(zip(grouped_words, grouped_times)):
                    start = self._format_time(time_start + start_offset)
                    end = self._format_time(time_start + end_offset)

                    font_size = self._calculate_font_size()
                    pos_offset = -1 if i%2 ==0 else 1
                    pos_x_still = 0 if i%3==0 else 1
                    pos_x = frame_width // 2
                    pos_x_new = pos_x + (pos_offset * pos_x_still* int(frame_width*0.05))# Slight horizontal shift
                    pos_y = frame_height // 1.5 # Centered text with gradual stacking
                    pos_y_still = 0 if i%3!=0 else 1
                    pos_x_new = pos_x + (pos_offset * pos_y_still * int(frame_height*0.05))# Slight horizontal shift

                    # **Advanced Effects**
                    effects = r"{\move(%d,%d,%d,%d,0,1000)\fad(200,200)\fs%d\bord2\shad1\1c&HFFFFFF&\t(0,1000,\fs%d)}" % (
                        pos_x, pos_y, pos_x_new, pos_y - 30, font_size, font_size + int(font_size*0.25)
                    )
         
                    file.write(f"Dialogue: 0,{start},{end},Default,,0,0,0,,{effects}{word_group}\n")
        print(f"Lyrics saved to {ass_file_name}")
        return ass_file_name

    def _split_word_durations(self, start_time, end_time, num_words):
        """Splits subtitle duration into per-word segments, with optional grouping for fast words."""
        duration = end_time - start_time
        word_time = duration / max(num_words, 1)
        return [(i * word_time, (i + 1) * word_time) for i in range(num_words)]

    def _group_fast_words(self, words, word_durations):
        """Groups words if they appear too fast (threshold < self.word_threshold)."""
        grouped_words = []
        grouped_times = []

        temp_words = []
        temp_start = word_durations[0][0]

        for i, (word, (start, end)) in enumerate(zip(words, word_durations)):
            if i > 0 and (start - temp_start) < self.word_threshold:
                temp_words.append(word)
            else:
                if temp_words:
                    grouped_words.append(" ".join(temp_words))
                    grouped_times.append((temp_start, start))
                temp_words = [word]
                temp_start = start

        if temp_words:
            grouped_words.append(" ".join(temp_words))
            grouped_times.append((temp_start, word_durations[-1][1]))

        return grouped_words, grouped_times

    def _format_time(self, seconds):
        """Formats time in HH:MM:SS.ms format for ASS subtitles."""
        h = int(seconds // 3600)
        m = int((seconds % 3600) // 60)
        s = int(seconds % 60)
        ms = int((seconds - int(seconds)) * 100)
        return f"{h:01d}:{m:02d}:{s:02d}.{ms:02d}"

    def _calculate_font_size(self):
        """Calculates a dynamic font size based on video resolution."""
        frame_width, frame_height = self.config.video_resolution
        return int((frame_width) * 0.2)

if __name__ == "__main__":
    # Example Usage
    config = Config('./', './')
    config.video_resolution = (1920, 1080)
    converter = AdvancedSRTtoASSConverter(config)
    converter.convert("input.srt", "output.ass")
