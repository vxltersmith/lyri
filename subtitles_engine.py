from config import Config
import re


class AdvancedSRTtoASSConverter:
    def __init__(self, config: Config):
        """Initialize with video frame dimensions for adaptive subtitles."""
        self.config = config
        self.word_threshold = 0.1  # Time (s) below which words will merge

    def _generate_ass_header(self):
        """Generates ASS header with video resolution for proper scaling."""
        return f"""[Script Info]
    ; Script generated by Liri.ai - your music-friendly bot
    Title: Word-Level Animated Subtitles
    ScriptType: v4.00+
    Collisions: Normal
    PlayResX: {self.config.video_resolution[0]}  ;
    PlayResY: {self.config.video_resolution[1]} ;
    PlayDepth: 0

    [V4+ Styles]
    Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
    Style: Default,Default,{self._calculate_font_size()},&H00FFFFFF,&H0000FFFF,&H00000000,&H64000000,-1,0,0,0,100,100,0,0,1,4,1,5,20,20,40,1

    [Events]
    Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
    """

    def convert(self, subs, ass_file_name, task_config: Config):
        """Convert SRT with word-level timestamps to animated ASS subtitle."""
        frame_width, frame_height = task_config.video_resolution
        frame_width, frame_height = (int(frame_width), int(frame_height))

        subs = self._group_fast_words(subs)
        font_size = self._calculate_font_size()

        with open(ass_file_name, "w", encoding="utf-8") as file:
            file.write(self._generate_ass_header())

            for i, sub in enumerate(subs):
                time_start = sub["start"]
                time_end = sub["end"]
                duration = time_end - time_start
                text = sub["word"]
                start = self._format_time(time_start)
                end = self._format_time(time_end)

                # Adjust for vertical video orientation
                pos_x = frame_height // 2
                pos_y = frame_width // 2  # Middle of the frame
                pos_y = pos_y + (frame_width - pos_y) // 3

                num_words = len(text.split(" "))
                if num_words > 1:
                    pos_x = frame_height
                    pos_x_final = 0
                else:
                    pos_x_final = pos_x

                # **Advanced Effects**
                final_font_size = max(
                    int(font_size * (min(duration, 0.35))), font_size - 1
                )
                effects = (
                    "{"
                    + f"\move({pos_x},{pos_y},{pos_x_final},{pos_y},0,{int(duration * 1000)})"
                    + f"\fs{font_size}\bord2\shad1\1c&HFFFFFF&"
                    + f"\t(0,{int(duration * 1000)},\\fs{final_font_size})"
                    + "}"
                )

                file.write(
                    f"Dialogue: 0,{start},{end},Default,,0,0,0,,{effects}{text}\n"
                )

        print(f"Lyrics saved to {ass_file_name}")
        return ass_file_name

    def _group_fast_words(self, words: list):
        """Groups words if they appear too fast (threshold < self.word_threshold)."""
        words_copy = [_.copy() for _ in words]
        new_words = []
        last_valid_sub = None

        for i, sub in enumerate(words_copy):
            sub["word"] = re.sub(r"[,.():;\]\[]", "", sub["word"])
            if "start" in sub and "end" in sub:
                new_words.append(sub)
                last_valid_sub = sub
            else:
                if last_valid_sub:
                    last_valid_sub["word"] += " " + sub["word"]
                    # Look ahead to find the next valid 'start' key
                    found_valid_start = False
                    for j in range(i + 1, len(words_copy)):
                        if "start" in words_copy[j]:
                            last_valid_sub["end"] = words_copy[j]["start"]
                            found_valid_start = True
                            break
                    if not found_valid_start:
                        # If no valid 'start' key is found, do nothing
                        continue
                else:
                    # If there's no valid subtitle before this one, just skip it
                    continue
        return new_words

    def _format_time(self, seconds):
        """Formats time in HH:MM:SS.ms format for ASS subtitles."""
        h = int(seconds // 3600)
        m = int((seconds % 3600) // 60)
        s = int(seconds % 60)
        ms = int((seconds - int(seconds)) * 100)
        return f"{h:01d}:{m:02d}:{s:02d}.{ms:02d}"

    def _calculate_font_size(self):
        """Calculates a dynamic font size based on video resolution."""
        frame_width, frame_height = self.config.video_resolution

        # Define a base font size for a standard resolution (e.g., 1080p)
        base_font_size = 40
        # Adjust the font size based on the frame width
        if frame_width >= 1920:
            # For Full HD (1080p) and above
            font_size = int(frame_width / base_font_size)
        elif frame_width >= 1280:
            # For HD (720p)
            font_size = int(frame_width / (base_font_size * 1.2))
        else:
            # For lower resolutions
            font_size = int(frame_width / (base_font_size * 1.5))

        return font_size


if __name__ == "__main__":
    # Example Usage
    config = Config("./", "./")
    config.video_resolution = (1080, 1920)  # Vertical video resolution
    converter = AdvancedSRTtoASSConverter(config)
    converter.convert("input.srt", "output.ass")
